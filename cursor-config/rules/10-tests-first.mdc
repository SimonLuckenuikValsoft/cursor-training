---
description: Test-driven development practices and test quality standards
globs: ["**/*.test.ts", "**/*.test.tsx", "**/*.spec.ts", "**/*.spec.tsx", "**/tests/**/*"]
alwaysApply: false
---

# Tests-First Development Rule

## Purpose
This rule enforces test-driven development (TDD) practices and ensures high-quality test coverage for all production code.

## Principles

### Write Tests Before Implementation
1. Start with a failing test that describes the desired behavior
2. Write minimal code to make the test pass
3. Refactor while keeping tests green
4. Repeat for each new feature or bug fix

### Test File Organization
- Place tests in a `tests/` directory or alongside source files with `.test.ts` suffix
- Mirror the source directory structure in test directories
- Name test files after the module they test: `UserService.test.ts`

### Test Quality Standards
- Each test should verify one specific behavior
- Tests should be independent and not rely on execution order
- Use descriptive test names that explain the expected behavior
- Follow Arrange-Act-Assert (AAA) pattern

### Coverage Requirements
- Minimum 80% line coverage for production code
- 100% coverage for critical paths (payments, authentication, data mutations)
- New code must include tests before merge

## Correct Example

```typescript
// Good: Descriptive names, AAA pattern, isolated tests
describe('UserService', () => {
  describe('createUser', () => {
    it('should create a user with valid input and return the user ID', async () => {
      // Arrange
      const userService = new UserService(mockRepository);
      const validInput = {
        email: 'test@example.com',
        name: 'Test User',
      };

      // Act
      const result = await userService.createUser(validInput);

      // Assert
      expect(result.success).toBe(true);
      expect(result.userId).toBeDefined();
      expect(mockRepository.save).toHaveBeenCalledWith(
        expect.objectContaining({ email: 'test@example.com' })
      );
    });

    it('should reject invalid email format and return validation error', async () => {
      // Arrange
      const userService = new UserService(mockRepository);
      const invalidInput = {
        email: 'not-an-email',
        name: 'Test User',
      };

      // Act
      const result = await userService.createUser(invalidInput);

      // Assert
      expect(result.success).toBe(false);
      expect(result.error).toContain('email');
      expect(mockRepository.save).not.toHaveBeenCalled();
    });
  });
});
```

## Incorrect Example

```typescript
// Bad: Vague names, no assertions, tests depend on each other
describe('UserService', () => {
  let createdUserId: string;  // Shared state between tests - bad

  it('test1', async () => {  // Non-descriptive name
    const svc = new UserService(mockRepo);
    createdUserId = await svc.create({ email: 'x@y.com', name: 'X' });
    // No assertions - test always passes
  });

  it('test2', async () => {
    // Depends on test1 running first - fragile
    const user = await svc.get(createdUserId);
    expect(user).toBeTruthy();  // Weak assertion
  });

  it('should work', async () => {  // Vague description
    // Testing multiple behaviors in one test
    const svc = new UserService(mockRepo);
    await svc.create({ email: 'a@b.com', name: 'A' });
    await svc.update('123', { name: 'B' });
    await svc.delete('123');
    // No clear expectation of what "work" means
  });
});
```

## Test Types

### Unit Tests
- Test individual functions and classes in isolation
- Mock external dependencies
- Fast execution (< 100ms per test)

### Integration Tests
- Test interactions between modules
- Use real or in-memory databases where appropriate
- Verify data flows correctly through the system

### End-to-End Tests
- Test complete user workflows
- Run against deployed or containerized environments
- Focus on critical paths only (slow to run)

## Enforcement
- CI pipeline fails if coverage drops below threshold
- PR reviews must verify test quality
- Cursor should suggest tests when generating new code
